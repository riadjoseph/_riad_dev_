import { ERROR_TRACKING_SUPPRESSION_RULES } from './constants';
import { createLogger } from './utils/logger';
import { propertyComparisons } from './utils/property-utils';
import { isArray, isString } from './utils/type-utils';
var logger = createLogger('[Error tracking]');
var PostHogExceptions = /** @class */ (function () {
    function PostHogExceptions(instance) {
        var _a, _b;
        this._suppressionRules = [];
        this._instance = instance;
        this._suppressionRules = (_b = (_a = this._instance.persistence) === null || _a === void 0 ? void 0 : _a.get_property(ERROR_TRACKING_SUPPRESSION_RULES)) !== null && _b !== void 0 ? _b : [];
    }
    PostHogExceptions.prototype.onRemoteConfig = function (response) {
        var _a;
        var _b, _c;
        var suppressionRules = (_c = (_b = response.errorTracking) === null || _b === void 0 ? void 0 : _b.suppressionRules) !== null && _c !== void 0 ? _c : [];
        // store this in-memory in case persistence is disabled
        this._suppressionRules = suppressionRules;
        if (this._instance.persistence) {
            this._instance.persistence.register((_a = {},
                _a[ERROR_TRACKING_SUPPRESSION_RULES] = this._suppressionRules,
                _a));
        }
    };
    PostHogExceptions.prototype.sendExceptionEvent = function (properties) {
        if (this._matchesSuppressionRule(properties)) {
            logger.info('Skipping exception capture because a suppression rule matched');
            return;
        }
        this._instance.capture('$exception', properties, {
            _noTruncate: true,
            _batchKey: 'exceptionEvent',
        });
    };
    PostHogExceptions.prototype._matchesSuppressionRule = function (properties) {
        var exceptionList = properties.$exception_list;
        if (!exceptionList || !isArray(exceptionList) || exceptionList.length === 0) {
            return false;
        }
        var exceptionValues = exceptionList.reduce(function (acc, _a) {
            var type = _a.type, value = _a.value;
            if (isString(type) && type.length > 0) {
                acc['$exception_types'].push(type);
            }
            if (isString(value) && value.length > 0) {
                acc['$exception_values'].push(value);
            }
            return acc;
        }, {
            $exception_types: [],
            $exception_values: [],
        });
        return this._suppressionRules.some(function (rule) {
            var results = rule.values.map(function (v) {
                var _a;
                var compare = propertyComparisons[v.operator];
                var targets = isArray(v.value) ? v.value : [v.value];
                var values = (_a = exceptionValues[v.key]) !== null && _a !== void 0 ? _a : [];
                return targets.length > 0 ? compare(targets, values) : false;
            });
            return rule.type === 'OR' ? results.some(Boolean) : results.every(Boolean);
        });
    };
    return PostHogExceptions;
}());
export { PostHogExceptions };
//# sourceMappingURL=posthog-exceptions.js.map